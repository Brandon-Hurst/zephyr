// Copyright (C) 2017 The Android Open Source Project
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This is a minimal subset of perfetto_trace.proto for Zephyr tracing.
// See https://github.com/google/perfetto/blob/main/protos/perfetto/trace/perfetto_trace.proto
// for the full proto definition.

syntax = "proto2";

package perfetto.protos;

// Root message containing the trace data.
message Trace {
  repeated TracePacket packet = 1;
}

// A TracePacket contains trace events and metadata.
message TracePacket {
  // Timestamp in nanoseconds since boot.
  optional uint64 timestamp = 8;

  // Trusted sequence ID - identifies the trace producer.
  optional uint32 trusted_packet_sequence_id = 10;

  // Sequence flags for incremental state.
  // SEQ_INCREMENTAL_STATE_CLEARED = 1
  // SEQ_NEEDS_INCREMENTAL_STATE = 2
  optional uint32 sequence_flags = 13;

  // One of the following data payloads:
  oneof data {
    TrackEvent track_event = 11;
    TrackDescriptor track_descriptor = 60;
    InternedData interned_data = 12;
  }

  // Optional timestamp clock ID (default is BOOTTIME = 6).
  // optional uint32 timestamp_clock_id = 58;
}

// Defines properties of a counter track, e.g. for built-in counters (thread
// time, instruction count, ..) or user-specified counters (e.g. memory usage of
// a specific app component).
//
// Counter tracks only support TYPE_COUNTER track events, which specify new
// values for the counter. For counters that require per-slice values, counter
// values can instead be provided in a more efficient encoding via TrackEvent's
// |extra_counter_track_uuids| and |extra_counter_values| fields. However,
// slice-type events cannot be emitted onto a counter track.
//
// Values for counters that are only emitted on a single packet sequence can
// optionally be delta-encoded, see |is_incremental|.
//
// Next id: 7.
message CounterDescriptor {
  // Built-in counters, usually with special meaning in the client library,
  // trace processor, legacy JSON format, or UI. Trace processor will infer a
  // track name from the enum value if none is provided in TrackDescriptor.
  /* enum BuiltinCounterType {
    COUNTER_UNSPECIFIED = 0;

    // Thread-scoped counters. The thread's track should be specified via
    // |parent_uuid| in the TrackDescriptor for such a counter.

    // implies UNIT_TIME_NS.
    COUNTER_THREAD_TIME_NS = 1;

    // implies UNIT_COUNT.
    COUNTER_THREAD_INSTRUCTION_COUNT = 2;
  } */

  // Type of the values for the counters - to supply lower granularity units,
  // see also |unit_multiplier|.
  enum Unit {
    UNIT_UNSPECIFIED = 0;
    UNIT_TIME_NS = 1;
    UNIT_COUNT = 2;
    UNIT_SIZE_BYTES = 3;
    // TODO(eseckler): Support more units as necessary.
  }

  // For built-in counters (e.g. thread time). Custom user-specified counters
  // (e.g. those emitted by TRACE_COUNTER macros of the client library)
  // shouldn't set this, and instead provide a counter name via TrackDescriptor.
  /* optional BuiltinCounterType type = 1; */

  // Names of categories of the counter (usually for user-specified counters).
  // In the client library, categories are a way to turn groups of individual
  // counters (or events) on or off.
  /* repeated string categories = 2; */

  // Type of the counter's values. Built-in counters imply a value for this
  // field.
  optional Unit unit = 3;

  // In order to use a unit not defined as a part of |Unit|, a free-form unit
  // name can be used instead.
  optional string unit_name = 6;

  // Multiplication factor of this counter's values, e.g. to supply
  // COUNTER_THREAD_TIME_NS timestamps in microseconds instead.
  optional int64 unit_multiplier = 4;

  // Whether values for this counter are provided as delta values. Only
  // supported for counters that are emitted on a single packet-sequence (e.g.
  // thread time). Counter values in subsequent packets on the current packet
  // sequence will be interpreted as delta values from the sequence's most
  // recent value for the counter. When incremental state is cleared, the
  // counter value is considered to be reset to 0. Thus, the first value after
  // incremental state is cleared is effectively an absolute value.
  // optional bool is_incremental = 5;

  // TODO(eseckler): Support arguments describing the counter (?).
  // repeated DebugAnnotation debug_annotations;

  // When visualizing multiple counter tracks, it is often useful to have them
  // share the same Y-axis range. This allows for easy comparison of their
  // values.
  //
  // All counter tracks with the same |y_axis_share_key| and the same parent
  // track (e.g. grouped under the same process track) will share their y-axis
  // range in the UI.
  // optional string y_axis_share_key = 7;
}

// Describes a track (process, thread, or custom track).
message TrackDescriptor {
  // Unique identifier for this track.
  optional uint64 uuid = 1;

  // Parent track UUID (for nesting).
  optional uint64 parent_uuid = 5;

  // Human-readable name.
  optional string name = 2;

  // Process descriptor (for process tracks).
  optional ProcessDescriptor process = 3;

  // Thread descriptor (for thread tracks).
  optional ThreadDescriptor thread = 4;

  optional CounterDescriptor counter = 8;

  /* Unused fields commented out:
  optional bool disallow_merging_with_system_tracks = 6;
  */
}

// Describes a process.
message ProcessDescriptor {
  optional int32 pid = 1;
  // repeated string cmdline = 2;
  optional string process_name = 6;
  /* Unused fields:
  optional int32 process_priority = 5;
  optional int64 start_timestamp_ns = 7;
  repeated int32 process_labels_iid = 8;
  */
}

// Describes a thread.
message ThreadDescriptor {
  optional int32 pid = 1;
  optional int32 tid = 2;
  optional string thread_name = 5;
  /* Unused fields:
  optional int32 thread_priority = 6;
  optional int64 reference_timestamp_us = 6;
  optional int64 reference_thread_time_us = 7;
  optional int32 reference_thread_instruction_count = 8;
  optional int64 legacy_sort_index = 3;
  */
}

// A track event (slice begin/end, instant event, counter).
message TrackEvent {
    // Names of categories of the event. In the client library, categories are a
    // way to turn groups of individual events on or off.
    // interned EventCategoryName.
    repeated uint64 category_iids = 3;
    // non-interned variant.
    repeated string categories = 22;

    // Optional name of the event for its display in trace viewer. May be left
    // unspecified for events with typed arguments.
    //
    // Note that metrics should not rely on event names, as they are prone to
    // changing. Instead, they should use typed arguments to identify the events
    // they are interested in.
    oneof name_field {
        // interned EventName.
        uint64 name_iid = 10;
        // non-interned variant.
        string name = 23;
    }

  // Event type.
  enum Type {
    TYPE_UNSPECIFIED = 0;
    TYPE_SLICE_BEGIN = 1;
    TYPE_SLICE_END = 2;
    TYPE_INSTANT = 3;
    TYPE_COUNTER = 4;
  }
  optional Type type = 9;

  // Track UUID this event belongs to.
  optional uint64 track_uuid = 11;

  // A new value for a counter track. |track_uuid| should refer to a track with
  // a CounterDescriptor, and |type| should be TYPE_COUNTER. For a more
  // efficient encoding of counter values that are sampled at the beginning/end
  // of a slice, see |extra_counter_values| and |extra_counter_track_uuids|.
  // Counter values can optionally be encoded in as delta values (positive or
  // negative) on each packet sequence (see CounterIncrementalBase).
  oneof counter_value_field {
    int64 counter_value = 30;
    double double_counter_value = 44;
  }

  // To encode counter values more efficiently, we support attaching additional
  // counter values to a TrackEvent of any type. All values will share the same
  // timestamp specified in the TracePacket. The value at
  // extra_counter_values[N] is for the counter track referenced by
  // extra_counter_track_uuids[N].
  //
  // |extra_counter_track_uuids| may also be set via TrackEventDefaults. There
  // should always be equal or more uuids than values. It is valid to set more
  // uuids (e.g. via defaults) than values. If uuids are specified in
  // TrackEventDefaults and a TrackEvent, the TrackEvent uuids override the
  // default uuid list.
  //
  // For example, this allows snapshotting the thread time clock at each
  // thread-track BEGIN and END event to capture the cpu time delta of a slice.
  repeated uint64 extra_counter_track_uuids = 31;
  repeated int64 extra_counter_values = 12;

  // Counter snapshots using floating point instead of integer values.
  repeated uint64 extra_double_counter_track_uuids = 45;
  repeated double extra_double_counter_values = 46;

  /* Unused fields commented out:
  repeated string categories = 22;
  optional uint64 flow_ids = 47;
  optional uint64 terminating_flow_ids = 48;
  repeated DebugAnnotation debug_annotations = 4;
  optional TaskExecution task_execution = 5;
  optional LogMessage log_message = 21;
  optional ChromeKeyedService chrome_keyed_service = 24;
  optional SourceLocation source_location = 26;
  optional ChromeLatencyInfo chrome_latency_info = 28;
  optional int64 thread_time_absolute_us = 16;
  optional int64 thread_instruction_count_absolute = 20;
  optional double double_counter_value = 44;
  repeated uint64 extra_counter_values = 45;
  repeated uint64 extra_counter_track_uuids = 31;
  repeated double extra_double_counter_values = 46;
  repeated uint64 extra_double_counter_track_uuids = 47;
  */
}

// Interned strings to reduce trace size.
message InternedData {
  repeated EventCategory event_categories = 1;
  repeated EventName event_names = 2;

  /* Unused interned data types:
  repeated DebugAnnotationName debug_annotation_names = 3;
  repeated DebugAnnotationValueTypeName debug_annotation_value_type_names = 27;
  repeated SourceLocation source_locations = 4;
  repeated LogMessageBody log_message_body = 20;
  repeated HistogramName histogram_names = 25;
  repeated Mapping mappings = 19;
  repeated Frame frames = 6;
  repeated Callstack callstacks = 7;
  repeated ProfiledFrameSymbols profiled_frame_symbols = 21;
  repeated BuildId build_ids = 16;
  repeated InternedString function_names = 5;
  repeated InternedString module_names = 17;
  repeated InternedString package_names = 22;
  repeated InternedString kernel_symbols = 14;
  repeated InternedGpuRenderStageSpecification gpu_specifications = 18;
  repeated UnsymbolizedSourceLocation unsymbolized_source_locations = 15;
  repeated V8String v8_js_function_name = 24;
  repeated V8String v8_wasm_script_url = 28;
  repeated V8String v8_isolate_code_ranges = 29;
  repeated V8String v8_js_script = 30;
  */
}

// Interned event category.
message EventCategory {
  optional uint64 iid = 1;
  optional string name = 2;
}

// Interned event name.
message EventName {
  optional uint64 iid = 1;
  optional string name = 2;
}
